---
layout: single
title : "CFDS1 c++ code sample 1"
---

---
Computing for Data Science
---

# Code Samples 1 : Practice

[TOC]

## 1st : Bears

### **Requirements**

- bear 객체는 get, set을 통해 weight property에 접근할 수 있어야 한다.
- bear가 얼마나 현재 mad 한가에 대한 상태 메시지를 Meanness() 로서 출력해내어야 한다.
  1) weight에 따라 결정되며, weight가 100 이하인 경우, weight의 2배 값,
  2) weight가 100 초과일 경우, weight의 3배 값으로 Meanness 값을 갖는다.
- momma bear 는 bear 객체를 확장하여, cub이라는 추가 멤버변수를 가져야 한다. 단, cub 또한 하나의 bear 객체이므로, cub은 bear을 가리키는 포인터여야 한다.
- mommabear는 일반적인 bear 보다 2배 더 mean하다.
- mommabear에게 cub이 있을 경우, cub의 meanness 까지 합쳐 TotalMeanness() 메시지를 반환해야 한다.

> 이를 요약하면 다음과 같다.
>
> |            | Instance variables | methods                      |
> | ---------- | ------------------ | ---------------------------- |
> | Bear       | weight             | SetWeight(float)             |
> |            |                    | GetWeight()                  |
> |            |                    | Meanness()                   |
> | moommabear | cub                | SetCub(Bear *)               |
> |            |                    | GetCub()                     |
> |            |                    | Meanness(),  TotalMeanness() |



### **Building a structure**



- **bear 클래스(class)**를 하나 형성한다.

  1) <u>bear의 멤버변수</u>

     1) **weight** : 아래의 SetWeight에서 설정되어야 하므로, float 타입의 변수로 선언하되, 초기화해서는 안된다.

  2) <u>bear의 멤버함수</u>

     1) **SetWeight(float)** : bear의 멤버변수인 weight를 설정한다.

     2) **GetWeight()** : bear의 멤버변수인 weight를 반환한다.

     3) **Meanness()** : Meanness를 형성하여 반환한다.

        weight\*2 (when weight >= 100)

        weight\*3 (otherwise)

        

- **mommabear 클래스(class)**를 하나 형성한다.

  1) <u>**상속** : bear를 상속한다.</u>

     1) 그러나 Meanness() 멤버 함수는 그 기능이 달라야 한다.
     2) 2배 더 높은 meanness 값을 반환하도록 한다.

  2) <u>mommabear의 멤버변수</u>

     1) **cub** : bear 객체를 가리키는 pointer로 선언해야 한다.

        단, cub은 처음에 null pointer로 선언해야 하고, 생성 이후, 추후에 접근하여 cub을 따로 설정할 수 있도록 하자.

  3) <u>mommabear의 멤버함수</u>

     1) **Setcub(Bear *)** : Bear 객체를 가리키는 포인터로서 Setsub 멤버함수를 정의하자.
     2) **Getcub()**: cub이 가리키는 Bear 객체를 반환하도록 하자. 
     3) **Totalmeanness()** : cub으로 가리키는 Bear 객체의 Meanness를 mommabear 자신의 Meanness와 합쳐 반환하도록 하자. 그러기 위해서는 Meanness가 어떤 구조를 가져야 할지 고민해봐야 할 것이다.
     4) **Meanness()** : 상속받는 객체의 Meanness()와 그 기능이 다르게 구현될 수 있도록 해야 한다.



### **Practice writing codes**

#### Bear.h

- 함수 선언할 때, { } 기호는 붙이지 않는다. 이는 추후 정의하는 ==cpp== 파일에서 붙여야 한다.
- default constructor를 호출하지 않고, argument를 받는 constructor를 호출하려면 반드시 선언부에 이를 명시해주도록 하자.
- 단, 생성자는 외부에서 당연히 접근 가능해야 할 것이므로 public에 정의하자.

```c++
class bear {
    protected:
    	float weight;
    public:
    	bear(float arg_weight);
    
    	void SetWeight(float);
    	float GetWeight(void);
    	virtual float Meanness(void);
};
```



#### Mommabear.h

- 상속받고자 하는 ==Bear.h==가 외부의 파일에 존재하므로 <span style="color:darkred">#include</span>를 통해서 아래와 같이 적어주도록 하자.
- Meanness는 ==virtual==로 선언해야 따로 구현할 수 있을 것이다. 여기서 주의할 점은, virtual로 선언된 각각에 대해서 따로 ==cpp==에 함수를 정확히 정의해주어야 한다는 것이다.
- sub class의 헤더파일을 작성할 때, 자주 실수하는 점 :  ==sub class의 constructor==를 선언하지 않는 것!
  - 그렇다면 mommabear의 생성자가 bear의 생성자와 동일한가? No!
  - mommabear만의 멤버변수인 ==cub==이 존재하기 때문! 즉, 이에 대한 초기화 과정도 거쳐야만 한다.
  - 따라서 별도의 생성자가 요구될 것이다.


```c++
#include "Bear.h"

class mommabear : public bear {
    private:
    	bear* cub;
    public:
    	mommabear(float arg_weight);
    	
    	void Setcub(bear*);
    	bear* Getsub(void);
    	float Totalmeanness(void);
    	virtual float Meanness(void);
};
```



#### Bear.cpp

- 역시, ==Bear.h==를 참조해야 하므로 <span style="color:darkred">#include</span>를 사용해주도록 하자.
- ==Bear.h== 파일을 봐가면서, 정의되어 있는 함수를 하나 하나 설정해주면 된다.
- 함수를 설정할 때는, 꼭 해당 class의 namespace를 명시해서 정의하고자 하는 함수명을 정확히 기재해주어야 한다.
- 함수 정의 시에는 함수 선언 시와 달리, **virtual을 입력하지 않는다**.

```c++
#include "Bear.h"

bear::bear(float arg_weight){
    weight = arg_weight;
};

void bear::SetWeight(float chg_weight){
    weight = chg_weight;
};

float bear::GetWeight(void){
    return weight;
};

// 선언할 경우에만, virtual을 쓸 수 있다. 정의할 때는 쓰지 않는다.
float bear::Meanness(void){
    if (weight >= 100){
        return (weight*2);
    }
    else{
        return (weight*3);
    }
};
```



#### Mommabear.cpp

- 역시, ==Mommabear.h==를 참조해야 하므로 <span style="color:darkred">#include</span>를 사용해주도록 하자.

- sub class인 mommabear의 생성자를 정의할 때, 주의해야 한다.

  - bear의 생성자를 자동으로 호출하거나, 명시적으로 어떻게 호출하라는지 정의해야 하기 때문

  - 즉, 멤버 변수를 super class 차원과, sub class 차원에서 모두 가져야 한다는 것이다

    - super class인 bear 객체도 생성해야 하는데, default constructor가 아닌, argument형 constructor가 정의되어 있어, 반드시 argument를 넣어줘야 하는 구조다.

    - 아래와 같이 구현하면 문제가 발생!

      > 두 개의 변수를 입력받아야 ==bear== 객체도 생성하고, 멤버변수 ==cub==도 값을 설정할 수 있는데, 그렇게 되면 mommabear의 경우, 생성자를 사용할 때 다른 문법을 써야 하기 때문에 혼동의 여지가 있다.
      >
      > (무엇보다 앞선 헤더파일의 정의와 충돌)
      >
      > ```c++
      > #include "mommabear.h"
      > 
      > mommabear::mommabear(bear arg_cub) : bear(arg_weight) {
      >     cub = &arg_cub
      > }
      > ```

    - 이렇게 구현해야 한다!

      ```c++
      #include "mommabear.h"
      
      mommabear::mommabear(float arg_weight) : bear(arg_weight){
          cub = NULL;
      };
      
      void mommabear::Setcub(bear* arg_cub){
          cub = arg_cub; // 같은 포인터가 복사되는 구조 (copy operator)
      };
      
      bear* mommabear::Getsub(void){
          return cub;
      };
      
      virtual float mommabear::Meanness(void){
          return (bear::Meanness()*2)
      };
      
      float mommabear::Totalmeanness(void){
          if (cub != NULL){
              return (Meanness() + cub->Meaness());
          }
          else{
              return (Meanness());
          }
      };
      
      // Meanness라고 하는 함수는 우리가 virtual 선언함! 
      // 즉, 여기서 호출하는 Meanness는 mommabear의 Meanness다.
      ```

      

    - 위 구현에서 헷갈리는 점

      1) sub class의 멤버함수를 설정할 때, super class의 멤버변수에 어떻게 접근하는가?
      2) sub class에도 동일한 멤버변수 명이 있다면, sub class를 지칭하기 때문에, 반드시 ==super class명::멤버변수명== 으로 써줘야 한다.
      3) sub class에 동일한 멤버변수 명이 없다면, 상관없다. 컴파일러가 알아서 처리해준다.
      4) 따라서 위 코드에서는 딱히 문제가 없다.

      ```c++
      virtual float mommabear::Meanness(void){
          // 여기서 문제가 발생한다. 앞서 bear의 weight를 private으로 설정했기 때문에
          // subclass에서 super class의 weight 값에 접근하지 못한다.
          // 즉, bear로서 갖는 weight에 접근하지 못하니, virtual 구현이 불가한 것!
          // 따라서 bear의 weight를 protected로 바꾸자.
          
          if (bear::weight >= 100){
              return (bear::weight*2);
          }
          else{
              return (bear::weight*3);
          }
      }
      ```

      

    - 그런데 위 코드에서는 굳이 Meanness()를 위와 같이 정의할 필요가 없다. super class에 정의된 멤버함수를 다시 한번 사용할 수 있기 때문이다.

      > sub class 내에서 super class의 멤버함수에 접근하려면, ==bear::Meanness()== 로 멤버변수와 같은 형식을 기재하면 된다. 멤버함수는 이름이 중복되는 경우가 많으니, ==bear:: namespace==를 달아주도록 하자.

      > ==NULL==을 코드 내에서 사용하고자 한다면, #include <stdio.h> 가 필요하다.






#### 테스트 파일을 구현하기 위한 조치

- mommabear.h에 다음의 멤버 함수를 정의하였다.

  - ```c++
    public:
    static void TestBears(void);
    ```

  - 선언된 클래스의 모든 객체가 공유하는 static 멤버 변수 / 멤버 함수

- mommabear.cpp에 이렇게 설정했다.

  - ```c++
    void mommabear::TestBears(void){
        bear* cub = new bear(50);
        mommabear* mom = new mommabear(300);
        
        cout<<cub->Meanness()<<endl;
        cout<<mom->Meanness()<<endl;
        
        mom->SetCub(cub);
        cub->SetWeight(75);
        
        cout<<mom->TotalMeanness()<<endl;
    }
    ```

  - ==static==이나 ==virtual==이나 선언하는 경우에는 명시하지만, 정의하는 영역에서는 언급하지 않는다.

  - 이렇게 설정할 경우, main.cpp에서 다음과 같은 구현이 가능해진다.

    ```c++
    #include "Bear.h"
    #include "Mommabear.h"
    
    void main(void) {
    	mommabear::TestBears();
    }
    
    // mommabear 객체를 선언하지 않더라도, 곧장 TestBears 멤버함수로 테스트가 가능하다.
    ```











---

## 2nd : Banking Problem

### **Requirements**

- <u>각 계정의 종류에 따라, bank accounts에 대한 정보</u>를 저장해야 한다.
  - **current balance**
  - **total number of transactions**
- <u>계정 종류</u>
  - Normal
    - depost 기능 구현 (멤버변수 current balance 영향)
    - withdraw 기능 구현 (멤버변수 current balance 영향)
    - 월 $5의 비용 청구
  - Nickle 'n Dime
    - *기본 동일*
    - withdraw마다 $0.50의 비용 청구
  - The Gambler
    - *기본 동일*
    - 49% 확률로 withdraw 금액의 0배가 차감
    - 51% 확률로 withdraw 금액의 2배가 차감





### Building a structure

- <u>**==추상 클래스==** **abstract class인 Account**</u>를 만들어야 한다.

  - 멤버변수

    - balance
    - transactions : 거래 시마다 1씩 증가해야 한다

  - 멤버함수

    - Withdraw(*float*) : current balance를 업데이트 하고, transaction을 1 늘린다.
    - Deposit(*float*) : current balance를 업데이트 하고, transaction을 1 늘린다.
    - GetBalance() : current balance를 반환해야 한다
    - EndMonth() : 1달에 한 번 fee를 차감한다.
    - EndMonthUtil() : account monthly summary 를 출력한다

    

- **<u>sub class로 MonthlyFee, NickleNDime, Gambler</u>**을 만들어야 한다.

  - 구현해야 할 메소드는 대체로 유사하다
  - 다만, 계정에 따라 polymorphism을 고려해야 할 것이다





### Practice writing Codes

- **<u>Abstract Class인 Account</u>** 생성하기 (헤더 파일, cpp 파일 결합)

  ```c++
  #include <stdio.h>
  #include <iostream>
  #include <string>
  using namespace std;
  
  class Account {
      protected:
      float balance;
      int transactions;
      
      public:
      Account(void); // balance와 transactions를 모두 0으로 초기화 (정의 시)
      virtual void Withdraw(float amt) = 0;
      void Deposit(float amt);
      float GetBalance(void);
      virtual void EndMonth(void) = 0;
      void EndMonthUtil(void); // 이건 무슨 기능인가?
      
      /*테스트 하기 위한 함수 생성*/
      static void TestOneMonth(void);
  };
  
  Account::Account(void){
      balance = 0;
      transactions = 0;
  };
  
  void Account::Deposit(float amt){
      balance += amt;
      transactions ++;
  };
  
  float Account::GetBalance(void){
      return (balance);
  };
  
  void Account::EndMonthUtil(void){
      cout<<"Transactions : "<<transactions<<" / Balance : "<<balance<<endl;
      transactions = 0; // 다시 거래는 0으로 초기화한다.
  };
  ```

  

- **<u>Sub Class인 Account</u>** 생성하기 (헤더 파일, cpp 파일 결합)

  ```c++
  #include <stdio.h>
  #include <iostream>
  #include <cstdlib>
  // 랜덤으로 정수를 반환하는 cstlib을 포함시켜야 한다
  
  using namespace std;
  
  class MonthlyFee: public Account {
      public:
      MonthlyFee(void);
      virtual void Withdraw(float amt);
      virtual void EndMonth(void);
  };
  
  MonthlyFee::MonthlyFee(void) : Account(){};
  // 이 부분은 디폴트로 자동 생성되기 때문에 굳이 기재 안해도 된다
  // initializer에서 위와 같이 인자를 받지 않는 디폴트 생성자를 호출할 때, void 쓰면 안 됨
  // 클래스 객체 생성할 때, void 안 쓰는 것과 같은 논리
  
  void MonthlyFee::Withdraw(float amt){
      Account::transactions ++;
      Account::balance -= amt;
  };
  
  void MonthlyFee::EndMonth(void){
      Account::balance -= 5;
      Account::EndMonthUtil();
  };
  
  
  class NickleNDime: public Account {
      public:
      NickleNDime(void);
      virtual void Withdraw(float amt);
      virtual void EndMonth(void);
  };
  
  NickleNDime::NickleNDime(void) : Account(){};
  
  void NickleNDime::Withdraw(float amt){
      Account::transactions ++;
      Account::balance -= amt;
  };
  
  void NickleNDime::EndMonth(void){
      Account::balance -= Account.transactions * 0.5;
      Account::EndMonthUtil();
  };
  
  
  class Gambler : public Account{
      public:
      // 이번에는 생성자를 쓰지 말아 보자. 굳이 필요 없으니
      virtual void Withdraw(float amt);
      virtual void EndMonth(void){Account::EndMonthUtil();};
      // 특별한 기능을 구현할 필요는 없고, super class에 있는 아이를 다시 실행하라
  };
  
  void Gambler::Withdraw(float amt){
      // %를 어떻게 나타낼 것인가? 아이디어 필요
      // rand() 는 랜덤으로 아무 값이나 생성한다.
      if (rand()%100 <= 50){ // 51% 표현식
          Account::balance -= amt*2;
      };
      Account::transactions ++;
  };
  ```

  

- **Main cpp 구현해보기**

  ```c++
  void main(void){
      Account::TestOneMonth();
  }
  ```

  TestOneMonth는 Account에 대한 static 함수로 정의해야, 객체 생성과 무관하게, Account class 관련 아이들에 대해 함수의 정의가 가능하다.

  > 그러면, static TestOneMonth라는 함수는 어떻게 구현해야 하는가?

  ```c++
  #define NUMACCOUNTS 20 // 매크로 상수 정의
  #include <iostream>
  using namespace std;
  
  static Account* RandomeAccount(void){
      switch (rand()%3) {
          case 0:
              return (new Gambler);
              break;
          case 1:
              return (new NickleNDime);
              break;
          case 2:
              return (new MonthlyFee);
              break;
      }
      return(0);
  }
  // 본질 : 랜덤으로 세 계정 객체 중 아무거나 생성해서
  // 동적 할당한 계정 객체 포인터 반환
  
  
  void Account::TestOneMonth(void){
      Account* accounts[NUMACCOUNTS];
      // Account 객체를 가리킬 수 있는 포인터들을 20개 포함하는 배열 accounts 선언
      int accountNum;
      int day;
      
      // account 생성하기
      for (accountNum = 0; accountNum < NUMACCOUNTS; accountNum++){
          accounts[accountNum] = RandomAccount();
          accounts[accountNum]->Deposit(100);
      }
      
      // 랜덤 거래 형성하기
      for (day = 1; day <= 31; day++){
          accountNum = rand()%20;
          // accounts 배열에 있는 20개 계정 객체 포인터 중 하나 고르기
          if (rand()%){
              accounts[accountNum]->Deposit(rand()%100);
          }
          else{
              accounts[accountNum]->Withdraw(rand()%100);
          };
      };
      
      for (accountNum = 0; accountNum < NUMACCOUNTS; accountNum ++){
          cout<<"Account : "<<accountNum<<endl;
          accounts[accountNum]->EndMonth();
      }
  }
  ```

  



























