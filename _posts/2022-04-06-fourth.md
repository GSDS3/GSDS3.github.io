---
Computing for Data Science 1
---

# C++ Grammar Summary & Practice 2 

# *: **Class** [1]*

[TOC]

## 1. Access Control

```c++
#include <iostream>
using namespace std;

class Box{
    private:
    double width;
    public:
    double length;
    void setWidth(double wid);
    double getwidth(void);
};

// Member functions definition
void Box::setWidth(double wid){
    width = wid;
}

double Box::getWidth(void){
    return width;
}

// Main program
int main(void){
    Box box; // Box box() (x) 디폴트 생성자 주의
    
    // (1) length를 설정해보자
    box.length = 10.0;
    
    // (2) width를 설정해보자
    box.setWidth(10.0);
        
	// 출력해보기
	cout<<"Length is "<<box.length<<endl;
    cout<<"Width is "<<box.getWidth()<<endl;
    return 0;
}
```

---

<u>What about **sub class**?</u>

```c++
#include <iostream>
#include <string>

using namespace std;

class Person {
private:
    string name;
protected:
    double weight;
    double height;
public:
    Person(string arg_name, double arg_weight, double arg_height);
    double GetWeight(void) const;
    double GetHeight(void) const;
};

Person::Person(string arg_name, double arg_weight, double arg_height) {
    name = arg_name;
    weight = arg_weight;
    height = arg_height;
};

double Person::GetWeight(void) const {
    return weight;
};

double Person::GetHeight(void) const {
    return height;
};

class B_player : public Person {
private:
    double ball_speed;
    double run_speed;
public:
    B_player(string arg_name, double arg_weight, double arg_height, double arg_bs, double arg_rs);
    void play(void);
};

B_player::B_player(string arg_name, double arg_weight, double arg_height, double arg_bs, double arg_rs) : Person(arg_name, arg_weight, arg_height) {
    ball_speed = arg_bs;
    run_speed = arg_rs;
};

void B_player::play(void) {
    Person::weight++;
    Person::height--;
};

int main(void) {
    B_player Tom("Tom", 70, 176, 140, 10);
    Tom.play();
    cout << "Weight " << Tom.GetWeight() << ". Height " << Tom.GetHeight() << endl;
    Tom.play();
    cout << "Weight " << Tom.GetWeight() << ". Height " << Tom.GetHeight() << endl;
    Tom.play();
    cout << "Weight " << Tom.GetWeight() << ". Height " << Tom.GetHeight() << endl;
    return 0;
};
```



## 2. General Constructors

- ==Default constructor==에 대해서 숙지 필요
- **Automatically called** whenever a new object of the class is created

<u>**사례 코드 1**</u>

```c++
#include <iostream>
using namespace std;

class Circle {
private:
    double radius;
public:
    Circle(double r) {
        radius = r;
    };
    double circum(void) {
        return (2 * radius * 3.14159265);
    };
};

int main() {
    Circle foo(10.0); // 함수형 생성자 호출
    Circle bar = 20.0; // 위는 아래와 같이 해석
    Circle baz{ 30.0 }; // 유니폼 생성자 호출
    Circle qux = { 40.0 }; // 같은 논리로 할당 가능

    Circle* container[4];
    container[0] = &foo;
    container[1] = &bar;
    container[2] = &baz;
    container[3] = &qux;

    for (Circle* iterator : container) {
        cout << iterator->circum() << endl;
    };
}
```

> <u>**기호 해석 주의할 것**</u>
>
> 1. Rectangle **rectb**;      :      디폴트 생성자 호출
> 2. Rectangle **rectc()**;      :       함수 선언!
> 3. Rectangle **rectd{}**;      :      디폴트 생성자 호출



**<u>디폴트 생성자 활용법</u>**

- parameter를 받지 않는 생성자다. 즉, argument가 없다.
  1. Account **example{}**;
  2. Account **example**;
- <u>디폴트란</u> 
  **어떠한 argument로도 초기화되지는 않지만**, 
  **객체가 생성되기는 한다**는 점에서 특이한 놈!

```c++
#include <iostream>
using namespace std;

class Rectangle {
private:
    int width, height;
public:
    Rectangle(void); // 디폴트 생성자
    Rectangle(int, int); // 오버로딩 된, 인수형 생성자
    int area(void) {
        return width * height;
    };
};

Rectangle::Rectangle(void) {
    width = 5;
    height = 5;
};

Rectangle::Rectangle(int a, int b) {
    width = a;
    height = b;
};

int main(void) {
    Rectangle ex1(3, 4);
    Rectangle ex2; // 디폴트 생성자 호출 (5, 5)
    Rectangle ex3 = Rectangle ();
    // 디폴트로 생성된 객체를 **반환**하는 우측 기호! (변수명 없음)
    // 그렇다면 이를 Rectangle 객체에 할당하면 되겠다!

    cout << ex1.area() << endl;
    cout << ex2.area() << endl;
    cout << ex3.area() << endl;
}
```

> 12 / 25 / 25



**<u>initializer 용법</u>**

```c++
Rectangle::Rectangle (int x, int y){
    width = x;
    height = y;
}

Rectangle::Rectangle (int x, int y) : width(x), height(y) {}

Rectangle::Rectangle (int x, int y) : width(x){
    height = y;
}
```

- <u>initializer를 반드시 써야만 하는 경우</u> (강의 중)

  - default constructor는 직접 정의할 수도 있고, 정의하지 않을 수도 있다.
  - default를 제외한 그 어떤 argument 형 생성자도 정의하지 않았을 경우에는, default 생성자를 사용할 수 있으나 (컴파일러가 생성)
  - argument 형 생성자는 정의하고, default 생성자는 정의하지 않은 경우라면, default 생성자를 쓸 수 없다.
  - 바로 위의 경우에는 initializer가 필요하다

  ```c++
  #include <iostream>
  using namespace std;
  
  class Circle {
  private:
      double radius;
  public:
      Circle(double r) : radius(r) {};
      double area(void) {
          return radius * radius * 3.14159265;
      };
  };
  
  class Cylinder {
  private:
      Circle base;
      double height;
  public:
      Cylinder(double r, double h) : base(r), height(h) {};
      /*
      그런데 이것도 가능한 것 아닌가? NO
      Circle() 만 객체를 반환한다
      
      Cylinder(double r, double h){
          base = Circle(r);
          height = h;
      }
      */
      double volume(void) {
          return base.area() * height;
      };
  };
  
  int main(void) {
      Cylinder foo(10, 20);
      cout << "volume " << foo.volume() << endl;
  }
  ```



## 3. Overloading Operators

```c++
#include <iostream>
using namespace std;

class CVector {
public:
    int x, y;
    CVector(void) {}; 
    // 진짜 아무것도 없는 디폴트 생성자. 임의로 값을 초기화
    CVector(int a, int b) : x(a), y(b) {};
    CVector operator + (const CVector&);
};

CVector CVector::operator+ (const CVector& param) {
    CVector temp; // 디폴트 생성자 호출
    temp.x = this->x + param.x;
    temp.y = this->y + param.y;
    return temp;
};

//CVector operator + (const CVector& lhs, const CVector& rhs) {
//    CVector temp;
//    temp.x = lhs.x + rhs.x;
//    temp.y = lhs.y + rhs.y;
//    return temp;
//};

int main(void) {
    CVector ex;
    CVector foo(3, 1);
    CVector bar(1, 2);
    CVector result;
    result = foo + bar;
    cout << ex.x << ',' << ex.y << endl;
    cout << result.x << ',' << result.y << endl;
}
```

- **위 코드에서 잘 봐야 할 점 : 2가지 구현이 모두 가능하다!**

  1) 주석처리 되지 않은 부분에서 this를 떼어도 상관 없음
     어차피 자기 영역의 x, y를 호출할 것이기 때문

  2) 주석처리 된 부분은 클래스 내에 정의한 것이 아니라, 별도로 선언한 것이다. 즉, 별도로 선언할 경우에는 위와 같이 처리해야 한다는 것

     > 단, 이 경우에는 class 내의 선언부를 삭제해줘야!



```c++
class Dummy{
    // 멤버변수가 없는 구조인 Dummy
	public:
    bool isitme(Dummy& param);
};

bool Dummy::isitme (Dummy& param){
    if (&param == this){
        return true;
    }
    else{
        return false;
    };
};

int main(void){
    Dummy a; // 생성자 자체가 정의되지 않음. 디폴트로 호출
    Dummy* b = &a;
    if (b->isitme(a)){
        cout << "yes";
    }
    else{
        cout<<"no";
    }
}
```

> **이를  operator == 에 대한 overloading으로 다시 구해보자.**
>
> 1) <u>class 내에 operator == 를 선언해서 구현하는 법</u>
>
> ```c++
> class Dummy {
>     // 멤버변수가 없는 구조인 Dummy
> public:
>     bool isitme(Dummy& param);
>     bool operator == (Dummy& another) {
>         if (&another == this) {
>             return true;
>         }
>         else {
>             return false;
>         };
>     };
> };
> ```
>
> 2. <u>class 외부에 별도로 함수를 정의해서 구현하는 법</u>
>
> ```c++
> bool operator == (const Dummy& left, const Dummy& right){
>     if (&left == &right){
>         return true;
>     }
>     else{
>         return false;
>     };
> };
> ```
>
> ```c++
> // Test
> int main(void) {
>     Dummy a;
>     Dummy b;
>     if (a == b) {
>         cout << "a & b : equal" << endl;
>     }
>     else {
>         cout << "a & b : unequal" << endl;
>     }
> 
>     Dummy* c = &a;
>     if (a == *c) {
>         cout << "a & c : equal" << endl;
>     }
>     else {
>         cout << "a & c : unequal" << endl;
>     }
> 
>     return 0;
> }
> ```



- **operator = (copy operator)** 는 반드시 클래스 내에 선언 및 구현되어야 한다

  ```c++
  
  class CVector {
  public:
      int x, y;
      CVector(void) { x = 0; y = 0; };
      // 진짜 아무것도 없는 디폴트 생성자. 임의로 값을 초기화
      CVector(int a, int b) : x(a), y(b) {};
      void operator = (const CVector& another) {
          x = another.x;
          y = another.y;
      };
  };
  
  int main(void) {
      CVector ex1{ 1, 2 };
      CVector ex2{ 3, 4 };
      cout << ex2.x << "," << ex2.y << endl; // 3,4
      ex2 = ex1;
      cout << ex2.x << "," << ex2.y << endl; // 1,2
      return 0;
  }
  ```



## 4. Static 변수, 함수

- **static data member**

  : class variable - there is only one common variable for all the objects of that same class, sharing the same value

- **static member function** **: static member가 아닌 멤버변수, 함수에 접근 불가!**

  1) member of a class that is <u>common to all object of that class</u>

  2) **act exactly as a  non-member function** <u>but being accessed like members of the class</u>

     결과적으로 **this 또한 사용 불가!*

```c++
// Dummy 객체가 총 몇 개 선언되었는지 세봐라!

class Dummy{
    public:
    static int n;
    Dummy(void){
        n++;
    };
};

int Dummy::n = 0;
// 상식적으로 당연히 static variable은 외부에서 초기화 필요

int main(void){
    Dummy a;
    Dummy b[5];
    cout << a.n << endl; // (1) 객체 잡아서 호출
    cout << Dummy::n << endl; // (2) 클래스 네임스페이스 호출
    
    Dummy* point = new Dummy;
    cout << a.n << endl;
}
```

> 6
> 6
> 7





## 5. Class Templates

> 비교해서 알아야 할 내용 : Function templates
>
> - STL 표준 템플릿 라이브러리를 잘 쓰기 위해서라도 반드시 이해 필요!
> - 간단한 구조이지만 문법을 제대로 암기해야 한다
>
> ### (1) Function templates
>
> - 기본 문법 구조
>   1. template으로 선언하고자 하는 함수 앞에
>      template <class T>를 붙인다.
>   2. T는 일반화된 type을 의미하므로, 경우에 따라 type을 다르게 구현하고자 하는 곳에 T를 붙이면 된다.
>   3. 복수의 class도 활용할 수 있다.
>   4. 함수 템플릿을 사용할 때, type에 대하여 명시하지 않을 경우, auto detecting 수행
>
> ```c++
> // 기본 문법 구조 : 1개 T
> 
> template <class T>
> T sum(T a, T b) {
>     return a + b;
> };
> 
> int main(void) {
>     int result = sum<int>(1, 2);
>     cout<<result;
>     return 0;
> }
> // <int>는 사용 시 생략 가능
> ```
>
> ```c++
> // 기본 문법 구조 : 2개 T
> 
> template <class T, class U>
> U sum(T a, U b) {
>     return (a + b);
> };
> 
> // 반환형에 대해서도 template T나 U를 적을 수 있다
> 
> int main(void) {
>     double result = sum<int, double>(1, 2.7);
>     cout << result;
>     return 0;
> }
> 
> // <int, double>은 사용시 생략 가능
> ```
>
> - 상수 자체를 집어넣을 수도 있다.
>   class를 넣었을 자리에, 상수화하고자 하는 변수 타입과 변수명을 기재
>
> ```c++
> template <class T, int N>
> T fixed_multiply (T val){
>     return (val * N);
> };
> 
> int main(){
>     cout<<fixed_multiply<int, 2>(10)<<endl;
>     cout<<fixed_multiply<float,3>(30.4)<<endl;
> }
> ```
>



**<u>사례 1</u>**

```c++
template <class T>
class mypair{
    T values[2];
    public:
    mypair (T first, T second){
        values[0] = first;
        values[1] = second;
    }
};

mypair<int> myobject (115, 36);
mypair<double> myobject (3.0, 2.18);

// map, vector를 구현하는 템플릿 구조와 동일
```



**<u>사례 2</u>**

```c++
template <class T>
class mypair{
    T a,b;
    public:
    mypair(T first, T second){
        a = first;
        b = second;
    };
    T getmax();
};

// 결국, Template class에 대한 function 역시,
// Template 구조라서 아래와 같은 모양을 갖는다.

template <class T>
T mypair<T>::getmax(){ // 템플릿 객체 선언과 유사
    T retval;
    if (a>b){
        retval = a; 

        // 여기서 a가 어떤 type인지 알아야 하기에 
        // mypair<T>를 선언한 것!
    }
    else{
        retval = b;
    };
    return retval;
};

int main(void){
    mypair<int> myobject(100, 75);
    cout << myobject.getmax()<<endl;
}
```



:star2:==**<u>사례 3</u>** : **template specialization**== - **<u>결국 overloading 개념</u>**

- 하나의 원소를 갖는 container를 만들어라
- 단, 그 원소의 type은 다양할 수 있다
- 그 중, 원소가 char인 경우, 다음의 함수를 다르게 정의해야 한다
  - char 이외의 type : 원소의 값을 1씩 증가시키는 increase 함수를 구현하라 (단, 그렇게 해서 증가된 값도 반환해야 한다)
  - char type : 소문자를 대문자로 바꾸는 uppercase 함수를 구현하라 (단, 그렇게 해서 대문자로 바뀐 문자도 반환해야 한다)

```c++
template <class T>
class container{
    T element;
    public:
    container(T argument): element(argument){};
    T increase(void){
        this->element ++;
        return(this->element);
    };
};

template <> // 여기서 빼는 대신
class container <char> { // 여기에 집어넣야 한다(type 명)
    char element;
    public:
    container(char argument): element(argument){};
    char uppercase(void){
        if ((element >= 'a') and (element <= 'z')){
            int interval = 'A' - 'a';
            this->element = element + interval;
            return (this->element);
        };
    };
};

int main(void){
    container<int> int_ex(1);
    container<char> char_ex('t');
    cout << int_ex.increase() << endl;
    cout << char_ex.uppercase() << endl;
}
```





## :star2::star2:==6. Special Constructors and Destructors==

- <u>**종류 및 기본 문법**</u>

  1) **Default constructor**

     ```c++
     Account::Account();
     ```

     > called when objects of a class are declared
     >
     > **not initialized with any arguments**
     >
     > - class 정의 부에서 constructor를 정의하지 않은 경우
     >   암묵적으로 default constructor를 갖는다고 가정!
     > - But! as soon as a class has **some constructor taking any number of parameters explicitly declared**, the compiler **no longer provides an implicit default constructor**, and <u>**no longer allows the declaration of new objects of that class without arguments**</u> ★

     

  2) **Destructor**

     ```c++
     Account::~Account();
     ```

     > Take no arguments and return nothing, not even void

     

  3) **Copy constructor**

     ```c++
     Account::Account (const Account& another);
     ```

     > When an object <u>is passed **a named object of its own type as argument**</u>, copy constructor is invoked **in order to construct a copy**
     >
     > - 문법은 위와 같이 정해져 있다
     > - 선언하지 않으면, shallow copy가 일어나므로, deep copy하게 정의해주어야 한다

     

  4) **Copy assignment**

     ```c++
     Account& operator = (const Account& another);
     ```

     > Copy assignment **Operator** is an overload of operator =
     >
     > which takes a value or reference of the class itself as parameter
     >
     > - 문법은 위와 같이 정해져 있다 (암기)
     > - 선언하지 않으면, shallow copy가 일어나므로, deep copy하게 정의해주어야 한다
     >
     > **<비교>**
     >
     > ```c++
     > Account foo; // 디폴트 생성자
     > Account bar(foo); // 카피 생성자
     > Account bax = foo; // 카피 생성자
     > foo = bar; // 카피 assignment
     > ```

     

     

  5) **Move constructor**

     ```c++
     Account::Account (Account&&);
     ```

     > Copying과 유사한 점
     >
     > - 다른 객체의 value를 사용하여 객체의 value를 부여
     >
     > Copying과 다른 점
     >
     > - 하지만 복사가 아니라, 파일 이동하듯 처리
     >
     > - This moving only happens **when the source of the value is an <u>unnamed object</u>**
     >
     >   :arrow_forward: 함수나 type-casts의 return value를 받는 경우가 많다
     >
     > 왜 써야 하는가?
     >
     > - overhead를 줄이기 위함
     > - temporary한 변수이름도 없는 아이들을 받을 때, 굳이 기존 메모리 공간을 보존해줄 필요가 없기 때문

     

  6) **Move assignment**

     ```c++
     Account& operator = (Account&&);
     ```

     > 



- **<u>사례</u>**

1) **Default constructor**

2) **Destructors**

   ```c++
   #include <iostream>
   using namespace std;
   
   class Example4 {
       string* ptr;
   public:
       // 디폴트 생성자 - 동적할당으로 정의
       Example4(void) :ptr(new string) {};
   
       Example4(const string& str) : ptr(new string(str)) {};
       // 동적할당 시, type을 명시해서 감싸야 한다
   
       // 소멸자
       ~Example4() {
           delete ptr;
       };
   
       // Accessor
       const string& content(void) const {
           return *ptr;
       };
   };
   
   int main(void) {
       Example4 foo;
       Example4 bar("Example");
   
       cout << "bar's content is " << bar.content();
       return 0;
   };
   ```



3. **Copy Constructor** : deep copy

   ```c++
   class Example5{
       private:
       string* ptr;
       string& ref;
       public:
       
       // 단순 생성자
       Example5(string& arg_str1, string& arg_str2): ptr(new string(arg_str1)), ref(string arg_str2) {};
       
       // 소멸자
       ~Example5(){
           delete ptr;
       };
       
       // copy constructor
       // 포인터, 참조자에 대한 deep copy가 목적!
       Example5(const string& alias): ptr(new string(alias.*ptr)), ref(alias.ref){};
       
       // 위와 같이 구현하면 오류 발생!
       // ptr과 ref는 private이기 때문에 접근 불가 (다른 객체)
       // accessor를 따로 구현 필요
   }
   ```

   ```c++
   #include <iostream>
   #include <string>
   using namespace std;
   
   class Example5 {
   private:
       string* ptr;
   public:
       Example5(string& arg_str1) : ptr(new string(arg_str1)) {};
       ~Example5() {
           delete ptr;
       };
   
       // copy constructor
       // 포인터, 참조자에 대한 deep copy가 목적!
       Example5(Example5& alias) : ptr(new string(alias.content_ptr())) {};
   
       string& content_ptr() {
           return *ptr;
       };
       void address_ptr() {
           cout << ptr << endl;
       };
   };
   
   int main(void) {
       string arg1 = "first";
       Example5 foo(arg1);
       Example5 bar(foo);
   
       cout << "foo's content: " << foo.content_ptr() << "(ptr) " << endl;
       cout << "bar's content: " << bar.content_ptr() << "(ptr) " << endl;
       cout << "foo's ptr address: ";
       foo.address_ptr();
       cout << "foo's ref address: ";
       bar.address_ptr();
   };
   ```

   > foo's content: first(ptr)
   > bar's content: first(ptr)
   > foo's ptr address: 000002661ECEF**EB0**
   > foo's ref address: 000002661ECEF**F20**
   >
   > 
   >
   > **구현 실패**
   >
   > ```c++
   > #include <iostream>
   > #include <string>
   > using namespace std;
   > 
   > class Example5 {
   > private:
   >     string* ptr;
   >     string& ref; // 애당초 문법 오류, 선언과 동시에 초기화 필요 (참조자)
   > public:
   >     Example5(string& arg_str1, string& arg_str2) : ptr(new string(arg_str1)), ref(arg_str2) {};
   >     ~Example5() {
   >         delete ptr;
   >     };
   > 
   >     // copy constructor
   >     // 포인터, 참조자에 대한 deep copy가 목적!
   >     Example5(Example5& alias) : ptr(new string(alias.content_ptr())), ref(alias.content_ref()) {};
   > 
   >     string& content_ptr() {
   >         return *ptr;
   >     };
   > 
   >     string& content_ref() {
   >         string temp = ref;
   >         return temp;
   >     };
   > 
   >     void address_ptr() {
   >         cout << ptr << endl;
   >     };
   > 
   >     void address_ref() {
   >         cout << &ref << endl;
   >     };
   > };
   > 
   > int main(void) {
   >     string arg1 = "first";
   >     string arg2 = "second";
   >     Example5 foo(arg1, arg2);
   >     Example5 bar(foo);
   > 
   >     cout << "foo's content: " << foo.content_ptr() << "(ptr) " << foo.content_ref() << "(ref)" << endl;
   >     cout << "bar's content: " << bar.content_ptr() << "(ptr) " << bar.content_ref() << "(ref)" << endl;
   >     cout << "foo's ptr address: ";
   >     foo.address_ptr();
   >     cout << "foo's ref address: ";
   >     foo.address_ref();
   >     cout << "bar's ptr address: ";
   >     bar.address_ptr();
   >     cout << "bar's ref address: ";
   >     bar.address_ref();
   > };
   > ```



4. **Copy Assignment**

   ```c++
   class Example5 {
   private:
       string* ptr;
   public:
       Example5(string& arg_str1) : ptr(new string(arg_str1)) {};
       ~Example5() {
           delete ptr;
       };
       
       // copy assignment 1 : 내 포인터의 값 바꾸기
       Example5& operator = (const Example& another){
           *ptr = another.content();
       }
       
       // copy assignment 2 : 새로운 포인터 할당
       Example5& operator = (const Example& another){
           delete ptr;
           ptr = new string(x.content());
           return *this;
           // *this = 나 자신의 object 자체
       }
   };
   ```



5. **Move Constructor**

   ```c++
   Account fn(); // 디폴트 생성자에 따른 object 반환
   Account foo; // 디폴트 생성자
   Account bar = foo; // 카피 생성자
   
   Account baz = fn(); 
   // 디폴트 생성자에 따라 생성된 object를 bax 생성 시에 배정
   // 이것이 move constructor
   
   foo = bar; // 카피 assignment
   
   baz = Account(); 
   // 디폴트 생성자에 따라 생성된 object를 배정
   // 이것이 move assignment
   ```

   ![16492538492565518575304625798916](C:\Users\user\Pictures\Samsung Flow\16492538492565518575304625798916.png)



- **<u>r-value 참조  [개념]</u>**

  - 실체가 없이 값을 제공하기 위한 목적으로만 사용되는 것 (상수, 함수 return 값)
  - 이와 달리, 값을 저장할 수 있는 실체가 있는 것을 l-value라고 한다.

  > r-value에 대한 참조 : &&
  >
  > l-value에 대한 참조 : &
  >
  > ```c++
  > Account& purse = account_1;
  > int&& exnum = 2; // 임시 객체 참조
  > const int& exnum_const = 2;
  > int&& result = Account.sum(); // 임시 객체 참조
  > ```

  

- :shit: 그래서 다음과 같이 표현할 수 있다. (문법)

  ```c++
  Account (Account&& obj); // 이동 생성자
  Account& operator = (Account&& obj); // 이동 assignment
  ```

  **<u>사례</u>** : ==복사, 이동 생성자에서는 대입되는 객체의 경우, private에 대해서도 아무렇게 접근 가능하다!==

  > 왜? : 자기 자신의 namespace에 있다고 보기 때문에

  ```c++
  using namespace std;
  
  class Example6{
      private:
      string* ptr;
      public:
      
      // 복사 생성자
      Example6(const string& str): ptr(new string(str)){};
      
      // 소멸자
      ~Example6(void){
          delete ptr;
      };
      
      // 이동 생성자. 그대로 포인터 가져옴
      Example6 (Example6&& x) : prt(x.ptr){
          x.ptr = nullptr; // 기존 것은 해제시킴
      }
      
      // 이동 assignment
      Example6& operator = (Example6&& x){
          delete ptr;
          ptr = x.ptr; // 그대로 포인터 가져옴
          x.ptr = nullptr; // 기존 것은 해제시킴
          return *this;
      };
      
      // accessor
      const string& content() const{
          return *ptr;
      };
      
      // adder : 이동 assignment 활용
      Example6 operator + (const Example6& rhs){
          return (Example6(content() + rhs.content()));
      };
      // 내재 원리 : Example6 = Example6(content() + rhs.content())
  };
  
  int main(void){
      // 일반 생성자
      Example6 foo ("Exam");
      
      // 이동 생성자 : 생성자 함수 결과 인스턴스 저장식
      Example6 bar = Example6("pie");
      
      // 이동 assignment
      foo = foo + bar;
      cout << "foo's content : "<<foo.content()<<endl;
  }
  ```

  > foo's content : example



6. **정의해주지 않으면 Implicit 하게 자동 생성되는 구조**

   ![image-20220406233553323](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20220406233553323.png)

   ```c++
   class Rectangle{
       private:
       int width, height;
       public:
       Rectangle(int x, int y): width(x), height(y){};
       
       // 디폴트 생성자를 컴파일러가 만들어주는 것으로 하겠다
       // 이를 명시적으로 표현하는 것!
       Rectangle(void) = default;
       
       // 복사 생성자를 자동 설정하지 못하게 막는 것
       // 복사 생성자 원천적으로 불가능해짐
       Rectangle(const Rectangle& other) = delete;
       
       int area(void){
           return width*height;
       };  
   };
   
   int main(void){
       Rectangle foo;
       Rectangle bar(10, 20);
       cout << "bar's area: "<< bar.area()<<endl;
   }
   ```

   > 결과적으로
   >
   > ```c++
   > Rectangle baz(foo); // 불가하다 (복사 생성자 불가)
   > ```
   >
   > ```c++
   > // 동일 1 (직접 정의하는 경우)
   > class Rectangle {
   > private:
   >     int width, height;
   > public:
   >     Rectangle(int x, int y) : width(x), height(y) {};
   >     Rectangle(void) = default;
   >     Rectangle(const Rectangle& other);
   >     int area(void) {
   >         return width * height;
   >     };
   > };
   > 
   > Rectangle::Rectangle(const Rectangle& other) : width(other.width), height(other.height) {};
   > 
   > int main(void) {
   >     Rectangle foo;
   >     Rectangle bar(10, 20);
   >     Rectangle zoo(bar);
   >     cout << "zoo's area: " << zoo.area() << endl;
   > }
   > ```
   >
   > ```c++
   > // 동일 2 (디폴트 호출) : 결과는 위와 같음
   > // 어차피 모두 복사하기 때문에
   > 
   > class Rectangle {
   > private:
   >     int width, height;
   > public:
   >     Rectangle(int x, int y) : width(x), height(y) {};
   >     Rectangle(void) = default;
   >     Rectangle(const Rectangle& other);
   >     int area(void) {
   >         return width * height;
   >     };
   > };
   > 
   > Rectangle::Rectangle(const Rectangle& other) = default;
   > 
   > int main(void) {
   >     Rectangle foo;
   >     Rectangle bar(10, 20);
   >     Rectangle zoo(bar);
   >     cout << "zoo's area: " << zoo.area() << endl;
   > }
   > ```

   



