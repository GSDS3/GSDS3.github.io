---
Computing for Data Science 1
---

# C++ Grammar Summary & Practice 1

[TOC]

## 1. OOP

### (1) Purpose

1. Abstracting **Realistic objects** into a **structured Data Objects**

2. **Member Variable** corresponds to the **properties** of real objects

   - memory size / layout

     > can also be accessed through **in the context of defining the concrete methods in itself**
     >
     > - member variable name
     > - **this ->** member variable name

3. **Member Functions** correspond to the **actions** of real objects

   - memory size / layout

   - methods they should implement

     > Likewise in the above example, it has the same principle of accessing the internal functions **when defining the concrete methods**
     >
     > - member function name
     > - **this ->** member function name

     > "this "pointer actually makes it possible for users access the data type in the context of  'client' level when defining the concrete contents
     >
     > - When a variable of the type is named as 'X'
     >
     >   ```c++
     >   X.Deposit(100);
     >   ```
     >
     > - We can substitute this in this way by using 'this' pointer
     >
     >   ```c++
     >   this->Deposit(100); 
     >   Deposit(100);
     >   // 위 두 결과는 동일
     >   ```
     >
     >   And **it's the only way that we can implement the methods in the namespace of the class**, which is not fully defined yet so that it's impossible to declare and initialize a specific object belonging to the class



### (2) Definition

- **object**

  - Run-time value that belongs to some class

    1) <u>**constuction**</u>

       > ```c++
       > Account account(100);
       > ```
       >
       > ```c++
       > Account account = Account(100);
       > ```
       >
       > ```c++
       > // 주의! 다음 두 개가 같은 것!
       > 
       > Account y;
       > Account y = Account();
       > ```
       >
       > - ==Account y 자체가 default constructor다==. (void)를 기재하지 말아야 함에 반드시 주의!
       > - Account y() 는 곧, Account y(void)로 함수 정의 꼴이 되어버린다. 주의하자!

       

       **default constructor는 다음과 같다**

       ```c++
       class Account{
       	Account(float initialAmount = 0.0);
       };
       
       Account x(100); // 100
       Account y; // 0.0
       ```

       

    2) **<u>Where to allocate the objects?</u>**

       - **STACK** 
         : declared like a local variable

         > destructed when the namespace ends

       - **HEAP** 
         : new / dynamically allocated

         > destructed when a destructor "delete" is called 

       - **inside a containing object**
         : data member inside of a containing object

         > follows a specific sequence (refer to the below)

       - **DATA**

         : declared like a global variable

         > automatically destructed when the program is over

        But, when **the object is declared as static variable** <u>inside the namespace of classes or functions</u>, it **continues to exist until the program is over**.

    

- **class**

  - Blueprint for its objects

  

- <u>Main **concepts** in OOP</u>

  1. ==**Abstraction**==

     1. representing essential features without including the background details
     2. represent more complex underlying code and data

     

  2. ==**Encapsulation**==

     1. the only way to access the data is provided by the functions (which are combined with the data)

     2. should make member **variable private**
        and access the variables through **public functions**

        - **public** : client-access level

        - **private** : implementor-access level

          > this makes it possible to **keep the abstraction and implementation separate**

        - **protected** : extended to the subclass implementor-access level

        

  3. ==**Inheritance**==

     1. capability to **define a new class in terms of an existing class**

     2. should **share some of the attributes of existing classes** (**classes have all the properties of their superclasses**)

     3. classes are arranged in a tree-like hierarchy

        - When a sub-class object is constructed, the process follows the sequence below

          >1) **contained object** is constructed first
          >2) **containing object** is constructed next
          >
          >But, when destructors are called, the sequence is reversed. In other words, **containing object should be deleted from the heap first**.

        - Contained object is **a kind of a data member of containing objects**

     4. 상속의 다양한 방법

        1. **public 상속** : 그대로 특성 유지
        2. **protected 상속** : super class의 멤버변수를 sub class의 protected 멤버변수로 받음
        3. **private 상속** : 모든 것을 sub class의 private멤버변수로 받음

        

  4. ==**Polymorphism**==

     1) capability of data to be processed in more than one form
     2) **same word means different things in different contexts (namespace)**
     3) **provision of a single interface to entities of different types**
     4) frequently used when a <u>**superclass pointer** is used to **refer to a subclass object**</u>
        - switch context / namespace of the functions from superclass
        - **into each subclass where the virtual functions are defined**
        - when the <u>same-word variables co-exist among various hierarchial classes</u>, the **variable closest to the current namespace** is automatically called
        - when it <u>doesn't find the one</u>, the search pointer just **goes upward until it finds another one in another super class**

     > - **virtual method**는 **runtime에서 object의 exact class가 결정**된다. 
     > - 이를 사용하지 않고자 한다면, obj->Foo()와 같이 해당 object의 이름을 명시해줘야 하는데, 
     > - 만약 다양한 type의 object가 반복문을 통해 같은 구문에 들어가는 구조라면, virtual method가 필수적일 것이다.



- Is it possible to **substitute the classes between supers and subs**?

  - subclass는 super class의 모든 properties와 methods를 갖기 때문에 가능하다.

  - 하지만 그 반대는 불가하다.

    > 단, 여기서 substitute라 함은, 말 그대로 대체한다는 의미가 아니라, 어떠한 객체를 어느 시점으로 바라볼 것인가에 가깝다.

  ```c++
  Bear* bear;
  Mommabear* mom;
  
  bear = mom; // ok
  mom = bear; // not ok
  ```

  ```c++
  Bear* bear;
  Mommabear* mom;
  
  void foo(Bear* arg_bear);
  void bar(Mommabear* arg_Mom);
  
  foo(mom); // Mommabear 객체를 Bear로 바라보는 것은 가능
  bar(bear); // 그 반대는 불가능
  ```





## 2. Dynamic programming

### (1) Dynamic objects

- When the heap memory has **no space left**, **new operator just returns NULL** 

  ```c++
  Account* account;
  account = new Account(100);
  
  delete account;
  
  // 포인터로 선언해야 new를 통해 생성한 Account의 주소를 할당 가능
  // 동 포인터 변수명을 delete한다고 해야 한다.
  ```

### (2) Dynamic Arrays

```c++
// c++에서는 char 형태로 배열이 아닌, string을 손쉽게 형성할 수 있다.
char* buff;
int i = 13;

buff = new char[1000];
delete [] buff;

// 변수로 기재할 수도 있다.
buff = new char[i];
delete [] buff;
```

- object로 구성된 array를 선언해서 다룰 수도 있다. array의 delete는 앞에 [ ] 를 붙여주도록 하자.

  ```c++
  Account* accounts;
  
  accounts = new Account[1000];
  delete [] accounts;
  ```

<u>추가 사례</u>

```c++
#include <iostream>
#include <string>
#include <sstream>
using namespace std;

int main(void) {
    int i, n;
    int* p;
    cout << "How many numbers would you like to type?";
    cin >> i;
    
    
    // (nothrow) 는 heap이 만석일 때, error를 return하지 않고
    // nullptr을 반환하도록 한다
    
    p = new (nothrow) int[i];
    
    
    
    if (p == nullptr) {
        cout << "Error: memory could not be allocated";
    }
    
    
    // nullptr은 굳이 delete 과정이 필요없다
    
    else {
        for (n = 0; n < i; n++) {
            cout << "Enter number: ";
            cin >> p[n];
        };
        cout << "You have entered : ";
        for (n = 0; n < i; n++) {
            cout << p[n] << ", ";
        };
        delete[] p;
    }
}
```





## 3. Const Programming

### (1) const variable

- 상수 선언하는 것이기에 variable의 value를 바꿀 수 없다.

  ```c++
  const char ch = 'x';
  // 추후 이에 대한 재정의가 불가!
  ```

- pointer, pointer variable에 대해서도 const를 선언할 수 있으나 주의해야 한다.

  ```c++
  // pointer가 가리키는 대상 제약
  // pointer->variable 변화 제약
  const char* const a = 'hi there';
  
  // pointer->variable 변화 제약
  const char* b = 'hi there';
  
  // pointer가 가리키는 대상 제약
  char* const c = 'hi there';
  ```

  > **<u>Quiz</u>** : Choose the ones that do not result in error messages.
  >
  > ```c++
  > a = 'a new one'; // 1
  > *a = 'hi'; // 2
  > a[2] = 'h'; // 3
  > 
  > b = 'a new one'; // 4
  > *b = 'hi'; // 5
  > b[2] = 'h'; // 6
  > 
  > c = 'a new one'; // 7
  > *c = 'hi'; // 8
  > c[2] = 'h'; // 9
  > ```
  >
  > - 4 , 8, 9



### (2) const method in class

- method 내에서 해당 class의 멤버 변수를 바꿀 수 없다.

  ```c++
  Account::GetBalance(void) const;
  ```





## 4. Stream Programming

### (1) Definition

- <u>an **entity** where a program can **either insert of extract chars to / from**</u>
  - **Source** of characters
  - **Destination** of characters

- Stream has its own **sequential order**
  - And never get back to the forth
  - which means we cannot recycle already used streams



### (2) Various Functions

- **<u>cout</u>**

  - buffer output, dividing the sentence word by word

- **<u>cin</u>**

  - buffer input (버퍼는 하드웨어와 소통하는 overhead를 최소화하여 속도를 향상시키기 위함이다)
  - 스페이스 바로 구분을 지을 수 있어도, 하나의 버퍼에 들어가는 것은 반드시 Enter로 구분된다

- **<u>endl</u>**

  - stream's buffer is flushed
  - \n

- <u>**getline (==cin==, ==string== object)**</u>

  - cin 버퍼에 들어간 내용을 한 line으로 읽어 한 방에 string object에 저장한다
  - 물론, object 는 string으로 선언된 객체여야 한다
  - 이를 응용하면 stringstream에서도 유사한 접근이 가능한데, 아래와 같다

- <u>**stringstream (==string== object)**</u>

  - #include <sstream>을 써줘야 한다.
  - string으로 선언된 아이를 한 방에, stream으로 인식해준다
  - 즉, cin 객체에 유저가 입력해주는 것과 같이 인식해주는 것이다

  두 가지 방법으로 stringstream 객체에 값을 넣어, temp에 넣어줄 수 있다

  ```c++
  // 단어 by 단어로 인식할 때
  stringstream(object) >> temp;
  
  // 문장 1줄로 인식할 때
  getline(stringstream(object), temp);
  ```

  ```c++
  // 단어 by 단어로 인식할 때
  stringstream ss;
  ss.std(object);
  ss >> temp;
  
  // 문장 1줄로 인식할 때
  stringstream ss;
  ss.std(object);
  getline(ss, temp);
  ```



**<u>사례 연습</u>**

```c++
#include <iostream>

using namespace std;

int main(void){
    int i;
    cout << "Input one integer value : " << endl;
    cin >> i;
    cout << "What you input follows as "<<i<<endl;
    
    int a;
    int b;
    cout << "Input two integer values a & b : " << endl;
    cout << "You should divide the word by space bar"<<endl;
    cin >> a >> b;
    cout << "What you input follows as "<<"a: "<<a<<" b: "<<b<<endl;
}
```

```c++
int a;
int b;
cin >> a >> b;

// 위 문장은 아래와 사실상 동일하다
cin >> a;
cin >> b;

// 이는 곧, cin의 stream 객체로 받아 buffer에 저장된 내용이 
// a, b에 하나 하나 씌워지기 때문
// flush해서 없애지 않는 한, 본질적은 같은 내용
// 물론 space bar로 기재하지 않고, 하나 하나 타이핑하는 것으로도 구현 가능한 것이 아래 코드의 차이점이다.
```



<u>getline과 stringstream을 활용한 코드 구성</u>

```c++
#include <iostream>
#include <sstream>
#include <string>

using namespace std;

void print(string obj){
    string temp;
    stringstream ss;
    ss.str(obj);
    getline(ss, temp);
    cout << temp;
};

/*
이렇게도 구현할 수 있다.
void print(string obj){
	string temp;
	getline(stringstream(obj), temp);
	cout << temp;
}
*/

int main(void){
    string input = "However hard it may be,"
				   "I bet, it will pay off in the end.";
    print(input);
	return 0;
};
```

> **<u>Result</u>**
>
> However hard it may be,I bet, it will pay off in the end.



<u>단어 by 단어로 출력하기</u>

```c++
#include <iostream>
#include <sstream>
#include <string>

using namespace std;

void print(string obj) {
    string temp;
    stringstream ss;
    ss.str(obj);
    while (ss >> temp) {
        cout << temp << endl;
    };
};

int main(void) {
    string input = "However hard it may be,"
        "I bet, it will pay off in the end.";
    print(input);
    return 0;
};
```

> **<u>Result</u>**
>
> However
> hard
> it
> may
> be,I
> bet,
> it
> will
> pay
> off
> in
> the
> end.





## 5. Constructor, Function & Default arguments

### (1) Constructor & Default arguments

```c++
```





### (2) Function & Default arguments

```c++
// 이와 같이 default를 앞에서부터 쌓으면 안된다.

int divide(int a = 0, int b){
    return (a/b);
}

int main(void){
    int v1 = 2;
    int v2 = 3;
    cout<<divide(v1, v2);
    // cout<<divide(v1); 오류 발생 : 무조건 순서대로 삽입
    return 0;
}


// default를 뒤에서부터 쌓아야 컴파일러가 오류를 일으키지 않는다.
// 상기와 같은 이유로!

double divide(int a, int b = 1) {
    return (a / b);
}

int main(void) {
    int v1 = 2;
    int v2 = 3;
    cout << divide(v1, v2)<<endl;
    cout << divide(v1);
    return 0;
}
```







## 6. Functions, Operators & Overloading

### (1) Functions and Overloading

- ==<u>주의점</u>== : **return type 만으로는 overloading이 불가**하다. 애당초 컴파일러가 식별할 수 없으므로

```c++
double divide(double a, double b = 1.0) {
    return (a / b);
}

int divide(int a, int b = 1) {
    return (a / b);
}

int main(void) {
    int v1 = 7;
    int v2 = 3;
    cout << divide(v1, v2) << endl;
    cout << divide(v1)<<endl;

    double t1 = 7.0;
    double t2 = 3.0;
    cout << divide(t1, t2) << endl;
    cout << divide(t1)<<endl;
    return 0;
}
```

> **Result**
>
> 2
> 7
> 2.33333
> 7



### (2) Operators and Overloading





## 7. Templates and examples

- STL 표준 템플릿 라이브러리를 잘 쓰기 위해서라도 반드시 이해 필요!
- 간단한 구조이지만 문법을 제대로 암기해야 한다

### (1) Function templates

- 기본 문법 구조
  1. template으로 선언하고자 하는 함수 앞에
     template <class T>를 붙인다.
  2. T는 일반화된 type을 의미하므로, 경우에 따라 type을 다르게 구현하고자 하는 곳에 T를 붙이면 된다.
  3. 복수의 class도 활용할 수 있다.
  4. 함수 템플릿을 사용할 때, type에 대하여 명시하지 않을 경우, auto detecting 수행

```c++
// 기본 문법 구조 : 1개 T

template <class T>
T sum(T a, T b) {
    return a + b;
};

int main(void) {
    int result = sum<int>(1, 2);
    cout<<result;
    return 0;
}
// <int>는 사용 시 생략 가능
```

```c++
// 기본 문법 구조 : 2개 T

template <class T, class U>
U sum(T a, U b) {
    return (a + b);
};

// 반환형에 대해서도 template T나 U를 적을 수 있다

int main(void) {
    double result = sum<int, double>(1, 2.7);
    cout << result;
    return 0;
}

// <int, double>은 사용시 생략 가능
```

- 상수 자체를 집어넣을 수도 있다.
  class를 넣었을 자리에, 상수화하고자 하는 변수 타입과 변수명을 기재

```c++
template <class T, int N>
T fixed_multiply (T val){
    return (val * N);
};

int main(){
    cout<<fixed_multiply<int, 2>(10)<<endl;
    cout<<fixed_multiply<float,3>(30.4)<<endl;
}
```





### (2) Class templates

```c++
```





## ==8. Call by value / Call by reference== (Return reference)

### (1) Call by value

- 본질은 argument의 값을 복사해서 copy 연산자 (=)를 사용하는 것



### (2) Call by Reference & Return Reference

- 본질은 argument의 메모리 자체에 접근하는 것
  - **pointer**를 사용하는 방식
  - **reference**를 사용하는 방식
    1) 한 번 설정되면 절대 바꿀 수 없다
    2) **선언과 동시에 초기화**되어야 한다

```c++
#include <iostream>
using namespace std;

void duplicate (int& a, int& b, int& c){
    a *= 2;
    b *= 2;
    c *= 2;
};

int main(void){
    int x=1, y=3, z=7;
    duplicate(x, y, z);
    cout<<"x is "<<x<<". y is "<<y<<". z is "<<z;
};
```

> **Result**
>
> x is 2. y is 6. z is 14

```c++
// When using pointers instead

#include <iostream>
using namespace std;

void duplicate(int* a, int* b, int* c) {
    *a *= 2;
    *b *= 2;
    *c *= 2;
};

int main(void) {
    int x = 1, y = 3, z = 7;
    duplicate(&x, &y, &z);
    cout << "x is " << x << ". y is " << y << ". z is " << z;
};
```

- **const References**

  alias를 통해서 original 값을 변하지 않게 하는 것. 애당초 값을 변경하는 것이 아니라, copy를 통한 메모리 낭비를 막고자 하는 것

```c++
#include <iostream>
#include <string>
#include <sstream>
using namespace std;

string concat(const string& s1, const string& s2){
    return (s1 + s2);
}

int main(void){
    string t1 = "ABCD EFGH";
    string t2 = "abcd efgh";
    string t3 = concat(t1, t2);
    cout<<t3;
}
```

> **Result**
>
> ABCD EFGHabcd efgh





## 9. Basic C Grammars

### 1) for loop

```c++
for (initialization; condition; increase / decrease){};
```



### 2) Range-based for loop

- 시작과 끝이 있는 모든 객체를 range에 넣을 수 있다
- declaration은 range에 들어간 객체의 element를 하나 하나 pointing해서 뽑아내기 위한 temp 객체라고 보면 된다
- 그런데 range에 들어간 객체의 type을 자동으로 인식해주는 auto라는 기능이 있다. declaration temp 객체의 type 명을 auto로 설정할 경우, 알아서 detect하여 type을 맞춰준다

```c++
for (declaration; range){};
for (auto declared temp : range object){};
```

<u>사례</u>

``` c++
#include <iostream>
#include <sstream>
#include <string>

using namespace std;

void print(string obj) {
    string temp;
    stringstream ss;
    ss.str(obj);
    getline(ss, temp);
    for (auto ch : temp) {
        cout << '[' << ch << ']';
    };
};


int main(void) {
    string input = "However hard it may be,"
        "I bet, it will pay off in the end.";
    print(input);
    return 0;
};
```

> **Result**
>
> ![image-20220405184025985](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20220405184025985.png)



### 3) main 함수의 Return 형

- **default 설정 값 : return 0;**

  > 프로그램이 성공적으로 종료되었음을 나타낸다
  >
  > return문을 main 함수에서 만나지 않았을 경우, 자동으로 return 0;을 호출한다

- **EXIT_SUCCESS**

  > #include <cstdlib> 이 필요하다
  >
  > return 0; 와 동일

- **EXIT_FAILURE**

  > 프로그램이 실패했음을 나타낸다



### 4) Scope와 Namespace

- 다음과 같이 scope를 달리할 수도 있다.
  즉, inner block과 outer block을 형성하는 것이다.

```c++
int main(void){
    int x = 10;
    {
        int x = 10;
        cout<<x<endl;
    }
    cout<<x<<endl;
    return 0;
};
```

- namespace라는 것은 scope에 접근하기 위하여, 특정 이름을 부여해준 것이다
- 선언하는 방식은 class와 동일하다 (사실 상 같은 구조)
- namespace는 class에서 멤버 함수를 정의했던 바와 같이, 구분해서 기재해 줄 수도 있다.

```c++
namespace foo{
    int value(void){
        return 5;
    };
}

namespace bar{
    const double pi = 3.1416;
    double value(void){
        return (2*pi);
    };
}

namespace foo{
    const string example = "anywhere";
}

int main(void){
    cout << foo::value() << endl;
    cout << bar::value() << endl;
    return 0;
};
```

- using namespace std; 로 간단히 풀이했었는데,

- using std::cout; 처럼 써도 된다

  즉, namespace의 특정 변수나 함수를 가져올 수 있다는 말!

```c++
using std::cout;

int main(void){
    cout<<45;
}
```

```c++
// namespace의 이름에 대하여 이렇게 alias를 부여할 수도 있다.

namespace new_name = current_name;
```





### 5) Arrays

- **Multidimensional Arrays**

  1. **Row-major order**를 따른다

  ```c++
  // 이를 육안으로 확인하는 방법
  
  #define WIDTH 5
  #define HEIGHT 3
  
  int matrix [HEIGHT][WIDTH];
  int n, m;
  int main(void){
      for (n = 0; n < HEIGHT ; n++){
          for (m = 0; m < WIDTH; m++){
              matrix[n][m] = (n+1)+(m+1);
          }
      }
  }
  ```

  2. Arrays as **Parameters**

     1. 메모리 블록 전체를 넘기는 것은 불가

     2. 메모리 주소의 시작은 넘길 수 있다

     3. c++에서는 **array에 대한 주소를 따로 구현해서 받을 수 있다**

        > 근본원리는 pointer가 배열의 주소를 받아 처리하는 것이나, 아래와 같이 직관적으로 array 자체를 받아서 처리하듯 수행할 수 있다.

  ```c++
  // C++에서 array의 index는 python의 index 구조와 동일
  
  void printarray(int arg[], int length){
      for (int n = 0; n < length; n++){
          cout << arg[n] << ' ';
      }
  }
  
  // 배열의 초기화에서는 배열의 크기를 명시하지 않아도 자동 처리
  // 하지만, manipulate 과정에서는 반드시 필요 (vector가 필요한 이유)
  
  int main(){
      int firstarray[] = {5, 10, 15};
      int secondarray[] = {2, 4, 6, 8, 10};
      printarray(firstarray, 3);
      printarray(secondarray, 5);
  }
  ```

  3) 다차원 배열에서 array을 argument로 삽입하게 되면, 반드시 차원을 잃어버리는 결과가 도출된다

     > argument로 들어오는 array는 결국 , 1차원밖에 인식하지 못하기 때문에
     >
     > - 따라서 1차원을 배제한 나머지 차원에 대해서는 index를 명시해주어야 한다

  ```c++
  void printarray(int arg[][1], int width){
      for (int n = 0; n < width; n++){
          cout << arg[n][1] << ' ';
      }
  }
  ```

  4. template으로 구현되어 있는 array를 사용해볼 수 있다. 이는 size를 멤버변수로 갖고 있다.

  ```c++
  #include <array>
  
  int main(void){
      array<int,3> myarray = {10,20,30};
      for (int i = 0; i < myarray.size(); ++i){
          ++myarray[i];
      };
      for (int elem : myarray){
          cout << elem << endl;
      }
  }
  ```





### 6) C string & C++ string

- c-string 에는 맨 끝에 null-terminater가 존재한다

```c++
char myword[] = "Hello";
cout<<myword[5];
```

> c-string과 c++ string 간의 치환에 대해 잘 정의되어 있음
>
> ```c++
> char myntcs[] = "some text";
> 
> // 배열 형태인 c-string은 string으로 이와 같이 형변환 가능
> string mystring = myntcs;
> 
> // .cstr()은 c++ string을 c string으로 형변환
> // stream 구조도 오버로딩에 근거하여 잘 출력한다
> cout<<mystring;
> cout<<mystring.c_str()
> ```





### 7) Pointers

- **Variable** : Named memory location

  1) memory를 형성

  2) memory에 대한 variable name을 형성

     > reference의 구조가 이에 따른다
     >
     > 즉, 같은 memory에 대해 이름만 달리하는 것이다

- **Pointer** : ==variable which stores the address of another variable==

  > pointer가 array의 첫 주소인 경우, pointer + int의 연산 결과, array의 길이를 초과할 수 있다. 즉, 범위를 넘어서 의도한 메모리 주소가 아니더라도 c++에서는 오류가 없다.

```c++
// 주의할 문법

int *p1, *p2; // pointer & pointer
int *p1, p2; // pointer & integer
```

> An array name is actually a constant pointer

```c++
// array와 pointer

int main(void){
    int numbers[5];
    int * p;
    p = numbers;
    *p = 10;
        
    p++; //pointer에 대한 연산구조 (한 칸씩 이동)
    *p = 20;
    
    p = &numbers[2];
    *p = 30;
    
    p = numbers + 3;
    *p = 40;
    
    p = numbers;
    *(p+4) = 50;
    
    for (int num : numbers){
        cout<<num<<endl;
    }
}
```

- ==**Pointer initializer**==

  ```c++
  // 기본적인 선언 구조
  int myvar;
  int * myptr = &myvar;
  
  // 변주
  int myvar;
  int * myptr;
  myprt = &myvar;
  
  // 다르다
  int myvar;
  int * myptr;
  *myptr = &myvar;
  
  // 근본 원리가 다르다
  int myvar;
  int * myptr;
  *myptr = myvar; // copy operator
  
  // 이것은?
  int myvar;
  int *foo = &myvar;
  int *bar = foo; // bar, foo가 동일한 메모리 포인트
  ```

- **Null Pointer**

  > Pointer는 선언과 동시에 디폴트 초기화가 되지는 않는다

  ```c++
  // 2가지 구현 방법이 존재
  
  int* p = 0;
  int* p = nullptr;
  ```

- **Pointer Arithmetic**

  1) **Different behavior with pointers**, <u>according to **==the size of the data type==** to which they point</u>

  2) Data type

     1) char : 1
     2) short : 2
     3) int : 4

  3) 연산자를 정확히 어떻게 써야 하는가?

     ```c++
     //복습 (기본)
     
     int x = 3;
     int y = ++x; // y = 4, x = 4
     
     int z = 3;
     int w = z++; // w = 3, z = 4
     ```

     ```c++
     1. *p++ = 	*(p++);
     // p의 참조 값 반환 & p를 한 스텝 이동
         
     2. *++p = 	*(++p);
     // p를 한 스텝 이동 & 이동한 p의 참조 값 반환
     
     3. ++*p = 	++(*p);
     // p의 참조값 증가
     
     4. (*p)++;
     // p의 참조값 증가
     ```

     ```c++
     // Example
     int main(void) {
         char var1[] = "Hello World!";
         char var2[] = "I'm a newbi";
     
         char* p = var1;
         char* q = var2;
     
         *p++ = *q++;
         // q의 참조값을 반환하고, pointer q 한 스텝 이동
         // p의 참조값을 q의 참조값으로 바꾸고, pointer p 한 스텝 이동
         for (char temp : var1) {
             cout << temp;
         };//Iello World!
         for (char temp : var2) {
             cout << temp;
         };//I'm a newbi
     
         *p = *q;
         // q의 참조값을 반환하고, p의 참조값을 이것으로 치환
         for (char temp : var1) {
             cout << temp;
         };// I'llo World!
         for (char temp : var2) {
             cout << temp;
         };//I'm a newbi
     
         ++p; // p[2]
         ++q; // q[2]
         for (char temp : var1) {
             cout << temp;
         };
         for (char temp : var2) {
             cout << temp;
         };
     }
     ```

     > **Result**
     >
     > Iello World!
     > I'm a newbi
     > I'llo World!
     > I'm a newbi
     > I'llo World!
     > I'm a newbi

  

  <u>실제 응용사례</u>

  ```c++
  void increment_all(int* start, int* stop){
      int* current = start;
      while (current != stop){
          ++(*current);
          ++current;
      }
  }
  
  void print_all(const int* start, const int* stop){
      const int* current = start;
      while (current != stop){
          cout<<*current<<endl;
          ++current;
      }
  }
  
  int main(void){
      int numbers[] = {10, 20, 30};
      
      // 마지막 null terminator 고려
      increment_all(numbers, numbers+3);
      print_all(numbers, numbers+3);
      return 0;
  }
  ```

- **Double pointer**

  ```c++
  char a;
  char* b;
  char** c;
  
  a = 'z';
  b = &a;
  c = b; // 에러; pointer간 copy operator이기에
  
  c = &b;
  ```

- **Void Pointer** : void\* pointer

  a special type of pointer that can <u>point to</u> **any type of data**

  ```c++
  void increase(void* data, int psize){
      if (psize == sizeof(char)){
          char* pchar;
          pchar = (char*) data; // type 부여 과정
          ++(*pchar);
      }
      else if (psize == sizeof(int)){
          int* pint;
          pint = (int*) data; // type 부여 과정
          ++(*pint);
      }
  }
  
  int main(void){
      char a = 'x';
      int b = 1602;
      increase(&a, sizeof(a));
      increase(&b, sizeof(b));
      cout << a << "," << b << endl;
  }
  ```

  































