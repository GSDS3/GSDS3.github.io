---
Computing for Data Science 1
---

# Code Samples 2 : Practice

[TOC]

## Requirements

- **Faculty, Lecturer, Grad**의 세 가지 객체를 생성하라.

- Instructor (Faculty, Lecturer, Grad) 는 다음의 세 가지 멤버변수를 가져야 한다.

  - unread e-mail messages
  - age
  - number of eccentricities

  단, instructor는 초기에 unread mail와 eccentricities가 없다.

- Instructor의 ==current mood==로서 Stress와 Respect를 고려하라.

  -  **Stress**는 다음과 같이 구현해야 한다.
    - unread messages의 수와 같다
    - Faculty, Lecturer는 1000을 넘을 수 없다
    - Grad는 unread messages*2와 같고, 2000을 넘을 수 없다
  - **Respect**는 다음과 같이 구현해야 한다.
    - age - the number of eccentricities이다
    - Respect는 항상 0 이상의 정수여야 한다
    - Faculty의 경우, age + the number of eccentricities이다
  
- Instructor가 new un-read e-mail을 수취할 때, 다음 일련의 과정을 거쳐야 한다

  - unread email의 수가 증가해야 한다.
  - 90%의 확률로 eccentricities의 변화가 없다.
  - 10%의 확률로 eccentricities의 값이 1씩 랜덤으로 올라가거나 내려갈 것이다.
  - Stress factor가 Respect factor를 초과하는 경우라면, 다음의 ==메커니즘==이 작동한다.
    - **Faculty**는 10 eccentricities를 얻게 된다
    - **Lecturer**는 unread mail의 절반을 지워버린다
    - **Grad** students는 모든 unread mail을 지워버리고, eccentricities의 값이 1씩 랜덤으로 올라가거나 내려갈 것이다
    - 단, 동 메커니즘은 mail batch 당 한 번만 작용할 수 있다.




## Building a structure

- **Instructor (Abstract Class)**
  - *member variables : 초기화를 0으로 해야 한다*
    - unreadMail
    - age
    - eccentricities
  - *member functions*
    - **<u>Stress()</u>**
      - mail의 수와 정확히 비례해야 한다
      - **Faculty, Lecturer**는 1000을 넘을 수 없다
      - **Grad**는 unread messages*2와 같고, 2000을 넘을 수 없다 ==virtual==
    - <u>**Respect()**</u>
      - other instructors : age - the number of eccentricities (단, 양수 조건 제약 필요)
      - **Faculty**는 age + the number of eccentricities ==virtual==
    - <u>**GetMail(int)**</u>
      - 일반 상황
        - mail의 수를 증가시켜야 한다
        - 10% 확률로 eccentricities를 랜덤 1, -1 변화
    - <u>**Cope()**</u>
      Stress() > Respect() : batch 당 딱 한번 수행
      - **Faculty**는 +10 eccentricities ==virtual==
      - **Lecturer**는 unread mail/2 ==virtual==
      - **Grad** students는 unread mail = 0, eccentricities를 랜덤 1, -1 변화 ==virtual==



## Practice Writing Codes

1. Instructor 구현하기

   ```c++
   #include <stdio.h>
   #include <cstdlib>
   
   using namespace std;
   
   class Instructor {
       protected:
       int unreadMail;
       int age;
       int eccentricities;
       public:
       Instructor(int arg_age);
       virtual int Stress(void);
       virtual int Respect(void);
       void GetMail(int);
       virtual void Cope(void) = 0;
       // Faculty, Lecturer, Grad 3개의 sub class가 갖고 있는 메소드가 각기 다르다
       // super class에서 별도로 정의할 수는 없지만, virtual은 선언해야 하는 구조 (pure virtual function)
   };
   
   Instructor::Instructor(int arg_age){
       unreadMail = 0;
       age = arg_age;
       eccentricities = 0;
   };
   
   // const 함수: 안의 값을 바꾸지 않겠다
   // (단, 관련 모든 Stress는 선언서부터 const 꼭 지정해야)
   // 위, 아래 실수한 부분 여럿 있음 주의할 것!
   
   int Instructor::Stress(void) const{
   
   /* 아래와 같이 정의하면 안 됨!
      Stress는 if문의 지역변수로 간주되어, 그 밖에서 활용 불가
       if (unreadMail <= 1000){
           int Stress = unreadMail;
       }
       else{
           int Stress = 1000;
       };
       return (Stress); */
       
       int Stress;
       if (unreadMail <= 1000){
           Stress = unreadMail;
       }
       else{
           Stress = 1000;
       };
       return (Stress);
   };
   
   int Instructor::Respect(void) const{
       int Respect;
       if (age - eccentricities < 0){
           Respect = 0;
       }
       else{
           Respect = age - eccentricities;
       }
       return (Respect);
   };
   
   void Instructor::GetMail(int){
       unreadMail ++;
       if (rand()%10 == 0){
           if (rand()%2 == 0){
               eccentricities += 1;
           }
           else{
               eccentricities -= 1;
           };
       };
       if (Stress() > Respect()){
           Cope();
       };
   /*
    Instructor의 namespace에서 Stress(), Respect(), Cope() 호출
    문제는 이 세 함수가 모두 virtual이라는 것
    Getmail은 virtual이 아니고, 모든 subclass에 대해서 적용
   각 객체에서 Getmail을 돌릴 때, Instructor::Getmail()을 실행하는 것인데, Instructor namespace에서 각 객체의 namespace에 접근해, 그곳에 정의된 함수를 호출해야 한다는 것이다.
    이를 구현하기 위한 절차가 virtual이고, virtual이 붙는다면, 동 객체의 namespace의 함수를 실행하게 된다.
   */
   };
   ```



2. Sub class 구현하기

   ```c++
   class Faculty: public Instructor{
       public:
       // sub class에서 생성자에 대해 정의해야 할까?
       // 해야 한다. 하나의 argument를 받아서 Instructor가 생성되기 때문에, default constructor에 의존할 수 없다.
       Faculty(int arg_age): Instructor(arg_age){};
       virtual int Respect(void){
           int Respect = Instructor::age + Instructor::eccentricities;
           return (Respect);
       };
       virtual void Cope(void){
         Instructor::eccentricities += 10;  
       };
   };
   
   class Lecturer: public Instructor{
       public:
       Lecturer(int arg_age): Instructor(arg_age){};
       virtual void Cope(void){
         unreadMail = unreadMail/2;  
       };
   };
   
   class Grad: public Instructor{
       public:
       Grad(int arg_age): Instructor(arg_age){};
       virtual int Stress(void){
           int Stress;
           if (unreadMail <= 1000){
           // unreadMail은 super class로 타고 올라가 가져옴
           // 만약 내 namespace 상 unreadMail이 있으면, 내 것을 우선 사용
               Stress = unreadMail * 2;
           }
           else{
               Stress = 2000;
           };
           return (Stress);
       };
       virtual void Cope(void){
           unreadMail = 0;
           if (rand()%2 == 0){
               eccentricities += 1;
           }
           else{
               eccentricities -= 1;
           };
       };
   };
   ```
